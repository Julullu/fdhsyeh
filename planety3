import functools
import os
import matplotlib.pyplot as plt
import numpy as np
import time
from scipy.integrate import solve_ivp

 
# Hmotnosti planet
M1=M2=M3= 1
# Vzdálenost mezi planetami
d=1.0 
# Počáteční rychlost obou planet
v1= 1.0

r_c=0.01

# Počáteční pozice a rychlosti
pocatecni_pozice_1= [d/2,0.0]
pocatecni_pozice_2= [-d/2,0.0]
pocatecni_pozice_3=[0.0,(d/2)*(3**0.5)]


pocatecni_rychlost_1= [((3**0.5)/2)*(-v1), (-v1)*0.5]
pocatecni_rychlost_2= [0.0, v1]
pocatecni_rychlost_3=[v1*(3**0.5)/2,(-v1)*0.5]



pocatecni_podminky= np.array([pocatecni_pozice_1, pocatecni_pozice_2, pocatecni_pozice_3,
                              pocatecni_rychlost_1, pocatecni_rychlost_2,
                              pocatecni_rychlost_3]).ravel()

# Časové intervaly (začátek, konec) a velikost kroku
time_s, time_e= 0, 5
velikost_kroku=0.001
t_points= np.arange(time_s, time_e+velikost_kroku, velikost_kroku)


# Systém obyčejných diferenciálních rovnic
def system_ode(t, S, M1, M2, M3):
   
    p1, p2, p3= S[0:2], S[2:4], S[4:6]
    dp1_dt, dp2_dt, dp3_dt= S[6:8], S[8:10], S[10:12]
    
    f1, f2, f3= dp1_dt, dp2_dt, dp3_dt

    df1_dt=  M2*(p2-p1)/np.linalg.norm(p2-p1)**3 + M3*(p3-p1)/np.linalg.norm(p3-p1)**3
    df2_dt=  M1*(p1-p2)/np.linalg.norm(p1-p2)**3 + M3*(p3-p2)/np.linalg.norm(p3-p2)**3
    df3_dt=  M1*(p1-p3)/np.linalg.norm(p1-p3)**3 + M2*(p2-p3)/np.linalg.norm(p2-p3)**3

    return np.array([f1, f2, f3, df1_dt, df2_dt, df3_dt]).ravel()

def runge_kutta_4(fun, t_span, y0, t_eval=t_points, args=()):
    y = np.zeros((len(y0), len(t_eval)))
    y[:, 0] = y0

    for i in range(1, len(t_eval)):
        h = t_eval[i] - t_eval[i-1]
        t_n = t_eval[i-1]
        y_n = y[:, i-1]

        k1 = fun(t_n, y_n, *args)
        k2 = fun(t_n + h/2, y_n + h/2 * k1, *args)
        k3 = fun(t_n + h/2, y_n + h/2 * k2, *args)
        k4 = fun(t_n + h, y_n + h * k3, *args)

        y[:, i] = y_n + (h/6) * (k1 + 2*k2 + 2*k3 + k4)

    return y



numericka_metoda= runge_kutta_4
numericka_metoda_jmeno= numericka_metoda.__name__
#Řešení ODE
solution= numericka_metoda(fun=system_ode,t_span=(time_s, time_e), y0= pocatecni_podminky, t_eval=t_points, args=(M1, M2, M3))

t_sol= t_points
p1x_sol, p1y_sol= solution[0], solution[1]
p2x_sol, p2y_sol= solution[2], solution[3]
p3x_sol, p3y_sol= solution[4], solution[5]
fig, ax = plt.subplots()

planet1_plt, = ax.plot(p1x_sol, p1y_sol, 'green', label='Planeta 1', linewidth=1)
planet2_plt, = ax.plot(p2x_sol, p2y_sol, 'red', label='Planeta 2', linewidth=1)
planet3_plt, = ax.plot(p3x_sol, p3y_sol, 'blue', label='Planeta 3', linewidth=1)

planet1_dot, = ax.plot([p1x_sol[-1]], [p1y_sol[-1]], 'o', color='green', markersize=7)
planet2_dot, = ax.plot([p2x_sol[-1]], [p2y_sol[-1]], 'o', color='red', markersize=7)
planet3_dot, = ax.plot([p3x_sol[-1]], [p3y_sol[-1]], 'o', color='blue', markersize=7)

collision_time = None

for i, t in enumerate(t_sol):
    r1 = np.array([p1x_sol[i], p1y_sol[i]])
    r2 = np.array([p2x_sol[i], p2y_sol[i]])

    distance = np.linalg.norm(r2 - r1)
    

    if distance < r_c:
        collision_time = t
        print(f"Kolize nastala v čase t = {t:.4f}")
        break

if collision_time is None:
    print("Ke kolizi nedošlo")

ax.set_title(f"Problém tří těles-{numericka_metoda_jmeno}, krok={velikost_kroku}")
ax.set_xlabel("x")
ax.set_ylabel("y")
plt.scatter([0],[(d/2)*(3**0.5)/2], color='black', s=20, label="Těžiště", marker='x')
if collision_time is not None:
    ax.plot(p1x_sol[i], p1y_sol[i], 'kx', markersize=10, label="Kolize")

plt.legend(loc="center left", bbox_to_anchor=(1, 0.5))
ax.set_aspect('equal')
plt.show()
