import functools
import os
import matplotlib.pyplot as plt
import numpy as np
import time
from scipy.integrate import solve_ivp

 
# Hmotnosti planet
M1=M2= 1
# Vzdálenost mezi planetami
d=1.0 
# Počáteční rychlost obou planet
v1= 1.0/(2**0.5)
v2=-v1
# Maximální přiblížení než nastane kolize
r_c=0.01
# Počáteční pozice a rychlosti
pocatecni_pozice_1= [d/2,0.0]
pocatecni_pozice_2= [-d/2,0.0]


pocatecni_rychlost_1= [0.0, v1]
pocatecni_rychlost_2= [0.0, v2]



pocatecni_podminky= np.array([pocatecni_pozice_1, pocatecni_pozice_2,
                              pocatecni_rychlost_1, pocatecni_rychlost_2]).ravel()

# Časové intervaly (začátek, konec) a velikost kroku
time_s, time_e= 0, 10
velikost_kroku=0.001
t_points= np.arange(time_s, time_e+velikost_kroku, velikost_kroku)

#Měření času metod (dekorátor)

def measure_time(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()        # začátek měření
        result = func(*args, **kwargs)  # volání funkce
        end_time = time.time()          # konec měření
        print(f"Funkce '{func.__name__}' běžela {end_time - start_time:.6f} s")
        return result
    return wrapper



# Systém obyčejných diferenciálních rovnic
def system_ode(t, S, M1, M2):
   
    p1, p2= S[0:2], S[2:4]
    dp1_dt, dp2_dt= S[4:6], S[6:8]

    
    f1, f2= dp1_dt, dp2_dt

    df1_dt=  M2*(p2-p1)/np.linalg.norm(p2-p1)**3
    df2_dt=  M1*(p1-p2)/np.linalg.norm(p1-p2)**3
    

    return np.array([f1, f2, df1_dt, df2_dt]).ravel()

#Numerické metody
@measure_time
def euler_method(fun, t_span, y0, t_eval=t_points, args=()):
    y = np.zeros((len(y0), len(t_eval)))
    y[:, 0] = y0

    for i in range(1, len(t_eval)):
        h = t_eval[i] - t_eval[i-1]
        t_n = t_eval[i-1]
        y_n = y[:, i-1]

        f_n = fun(t_n, y_n, *args)
        y[:, i] = y_n + h * f_n

    return y

@measure_time
def runge_kutta_4(fun, t_span, y0, t_eval=t_points, args=()):
    y = np.zeros((len(y0), len(t_eval)))
    y[:, 0] = y0

    for i in range(1, len(t_eval)):
        h = t_eval[i] - t_eval[i-1]
        t_n = t_eval[i-1]
        y_n = y[:, i-1]

        k1 = fun(t_n, y_n, *args)
        k2 = fun(t_n + h/2, y_n + h/2 * k1, *args)
        k3 = fun(t_n + h/2, y_n + h/2 * k2, *args)
        k4 = fun(t_n + h, y_n + h * k3, *args)

        y[:, i] = y_n + (h/6) * (k1 + 2*k2 + 2*k3 + k4)

    return y

@measure_time
def backward_euler_method(fun, t_span, y0, t_eval=t_points, args=(), tol=1e-6, max_iter=100):

    y = np.zeros((len(y0), len(t_eval)))
    y[:, 0] = y0

    for i in range(1, len(t_eval)):
        h = t_eval[i] - t_eval[i-1]
        t_n = t_eval[i-1]
        y_n = y[:, i-1]

        # Počáteční odhad pro y_{n+1}
        y_next = y_n.copy()

        for iteration in range(max_iter):
            f_next = fun(t_n + h, y_next, *args)
            y_new = y_n + h * f_next

            if np.linalg.norm(y_new - y_next) < tol:
                break

            y_next = y_new

        y[:, i] = y_next

    return y

@measure_time
def symplectic_euler_method(fun, t_span, y0, t_eval=t_points, args=()):
    y = np.zeros((len(y0), len(t_eval)))
    y[:, 0] = y0

    for i in range(1, len(t_eval)):
        h = t_eval[i] - t_eval[i-1]
        t_n = t_eval[i-1]
        y_n = y[:, i-1]

        # Rozdělení na pozice a rychlosti
        p1, p2 = y_n[0:2], y_n[2:4]
        dp1_dt, dp2_dt = y_n[4:6], y_n[6:8]

        # Aktualizace rychlostí
        df1_dt = M2 * (p2 - p1) / np.linalg.norm(p2 - p1)**3
        df2_dt = M1 * (p1 - p2) / np.linalg.norm(p1 - p2)**3

        dp1_dt_new = dp1_dt + h * df1_dt
        dp2_dt_new = dp2_dt + h * df2_dt

        # Aktualizace pozic
        p1_new = p1 + h * dp1_dt_new
        p2_new = p2 + h * dp2_dt_new

        # Uložení nových hodnot
        y[:, i] = np.array([p1_new[0], p1_new[1], p2_new[0], p2_new[1],
                            dp1_dt_new[0], dp1_dt_new[1], dp2_dt_new[0], dp2_dt_new[1]])

    return y

@measure_time
def verlet_integration(fun, t_span, y0, t_eval, args=()):
    y = np.zeros((len(y0), len(t_eval)))
    y[:,0] = y0
    v0= fun(t_eval[0], y0, *args)  # počáteční rychlosti

    h = t_eval[1] - t_eval[0]
    f0 = fun(t_eval[0], y0, *args)


    # první krok pomocí Taylorova rozvoje
    y[:,1] = y0 + h*v0 + 0.5*h**2*f0

    # hlavní cyklus
    for i in range(1, len(t_eval)-1):
        h = t_eval[i+1] - t_eval[i]
        t_n = t_eval[i]
        y_n = y[:,i]
        f_n = fun(t_n, y_n, *args)
        y[:,i+1] = 2*y_n - y[:,i-1] + h**2*f_n

    return y


# Zde můžete vybrat jednu z numerických metod
numericka_metoda= backward_euler_method
numericka_metoda_jmeno= numericka_metoda.__name__
#Řešení ODE
solution= numericka_metoda(fun=system_ode,t_span=(time_s, time_e), y0= pocatecni_podminky, t_eval=t_points, args=(M1, M2))

t_sol= t_points
p1x_sol, p1y_sol= solution[0], solution[1]
p2x_sol, p2y_sol= solution[2], solution[3]
fig, ax = plt.subplots()

planet1_plt, = ax.plot(p1x_sol, p1y_sol, 'green', label='Planeta 1', linewidth=1)
planet2_plt, = ax.plot(p2x_sol, p2y_sol, 'red', label='Planeta 2', linewidth=1)


planet1_dot, = ax.plot([p1x_sol[-1]], [p1y_sol[-1]], 'o', color='green', markersize=7)
planet2_dot, = ax.plot([p2x_sol[-1]], [p2y_sol[-1]], 'o', color='red', markersize=7)
 
collision_time = None

for i, t in enumerate(t_sol):
    r1 = np.array([p1x_sol[i], p1y_sol[i]])
    r2 = np.array([p2x_sol[i], p2y_sol[i]])

    distance = np.linalg.norm(r2 - r1)
    

    if distance < r_c:
        collision_time = t
        print(f"Kolize nastala v čase t = {t:.4f}")
        break

if collision_time is None:
    print("Ke kolizi nedošlo")


ax.set_title(f"Problém dvou těles-{numericka_metoda_jmeno}, krok={velikost_kroku}")
ax.set_xlabel("x")
ax.set_ylabel("y")
plt.scatter([0],[0], color='black', s=20, label="Těžiště", marker='x')
if collision_time is not None:
    ax.plot(p1x_sol[i], p1y_sol[i], 'kx', markersize=10, label="Kolize")

plt.grid()
plt.legend(loc="center left", bbox_to_anchor=(1, 0.5))
ax.set_aspect('equal')
plt.show()


    

def overeni_presnosti_energie(t_sol, pocatecni_rychlost_1, d):
    # Počáteční energie
    presna_energie = -M1*M2/d + 0.5*M1*(pocatecni_rychlost_1[1]**2) + 0.5*M2*(pocatecni_rychlost_1[1]**2)

    # Pole pro energii v každém časovém bodě
    E = np.zeros(len(t_sol))

    for i in range(len(t_sol)):
        r1 = np.array([solution[0,i], solution[1,i]])
        r2 = np.array([solution[2,i], solution[3,i]])
        v1 = np.array([solution[4,i], solution[5,i]])
        v2 = np.array([solution[6,i], solution[7,i]])

        T = 0.5*M1*np.dot(v1,v1) + 0.5*M2*np.dot(v2,v2)
        U = -M1*M2/np.linalg.norm(r1-r2)
        E[i] = T + U

    # Chyba energie
    chyba_energie = np.abs(E - presna_energie)
    chyba_energie_procenta= (chyba_energie / np.abs(presna_energie)) * 100

    # Vykreslení grafu
    plt.figure()
    plt.plot(t_sol, chyba_energie_procenta, 'b')
    plt.xlabel("Čas")
    plt.ylabel("Chyba energie (%)")
    plt.title(f"Chyba celkové energie v čase - {numericka_metoda_jmeno}, krok={velikost_kroku}")
    plt.grid()
    plt.show()

# Zavolání funkce
overeni_presnosti_energie(t_sol, pocatecni_rychlost_1, d)


def overeni_presnosti_chyba(solution, t_points):
    celkova_chyba_1 = np.zeros(len(t_points))  # pole pro chybu v každém časovém bodě
    celkova_chyba_2 = np.zeros(len(t_points))
    chyba_v_procentech = np.zeros(len(t_points))
    for i, t in enumerate(t_points):
        t_period = (d/ v1)*np.pi
        ubehly_cas = t % t_period
        uhel = pocatecni_rychlost_1[1] * ubehly_cas / (d * np.pi) * 360
        uhel_rad = np.deg2rad(uhel)

        presna_poloha_1 = np.array([d/2*np.cos(uhel_rad), d/2*np.sin(uhel_rad)])
        presna_poloha_2 = np.array([-d/2*np.cos(uhel_rad), -d/2*np.sin(uhel_rad)])

        r1 = np.array([solution[0,i], solution[1,i]])
        r2 = np.array([solution[2,i], solution[3,i]])

        chyba_poloha_1 = np.linalg.norm(r1 - presna_poloha_1)
        chyba_poloha_2 = np.linalg.norm(r2 - presna_poloha_2)
        

        celkova_chyba_1[i] = chyba_poloha_1
        celkova_chyba_2[i] = chyba_poloha_2
        chyba_v_procentech[i]= (celkova_chyba_1[i] / np.linalg.norm(presna_poloha_1)) * 100+ (celkova_chyba_2[i] / np.linalg.norm(presna_poloha_2)) * 100

    
    plt.figure()
    plt.plot(t_points, chyba_v_procentech, 'b')
    plt.xlabel("Čas")
    plt.ylabel("Celková chyba pozice (%)")
    plt.title(f"Celková chyba pozice v čase - {numericka_metoda_jmeno}, krok={velikost_kroku}")
    plt.grid()
    plt.show()

# Zavolání funkce
overeni_presnosti_chyba(solution, t_points)  

